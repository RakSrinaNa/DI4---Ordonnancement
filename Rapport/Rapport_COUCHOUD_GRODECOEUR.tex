\documentclass[hideweeklyreports]{polytech/polytech}
\usepackage{lmodern}
\usepackage{textcomp}

\usepackage{graphicx}
\usepackage{float}
\usepackage{pict2e}
\usepackage[justification=centering]{caption}

\newcommand{\img}[3]{%
	\begin{figure}[H]
		\centering
   		\includegraphics[scale=#3]{Images/#1}
  	 	\caption{#2}
	\end{figure}
}
\newcommand{\imgr}[4]{%
   \begin{figure}[H]
      \centering
         \includegraphics[scale=#3,rotate=#4]{Images/#1}
         \caption{#2}
   \end{figure}
}

\schooldepartment{di}
\typereport{ppgldi4}
\reportyear{2017-2018}
\title{Passage d'un algorithme Tabou du langage Python au langage C}
\subtitle{Algorithme Tabou en C}
\student{Thomas}{Couchoud}{thomas.couchoud@etu.univ-tours.fr}
\student{Clément}{Grodecoeur}{clement.grodecoeur@etu.univ-tours.fr}
\academicsupervisor{Jean-Charles}{Billaut}{jean-charles.billaut@univ-tours.fr}


\resume{Résumé FR} %TODO : Clément
\motcle{CHU, Trousseau, Chimiothérapie, Ordonnancement, Production, Livraison, Tabou, Swap, EBSR, EFSR}

\abstract{Abstract EN} %TODO: Clément
\keyword{Hospital, Trousseau, Chemotherapy, Schedule, Production, Delivery, Tabu, Swap, EBSR, EFSR}

\begin{document}
	\chapter{Contexte de la réalisation}
		Dans le cadre de notre formation à Polytech'Tours, nous avons eu l'occasion de travailler sur un projet concret grâce au projet encadré. Ce dernier vise à traduire un algorithme tabou du language Python vers du C.
		
		L'unité de Biopharmacie Clinique Oncologique du CHU Trousseau de Tours prépare des traitements de chimiothérapie (médicaments anticancéreux cytotoxiques) pour des patients. Ce processus est différent pour chaque préparation mais suit les même étapes.
		
		Les contraintes majeures sont les suivantes:
		\begin{itemize}
			\item Le traitement ne peut pas être préparé trop en avance.
			\item Les dosages sont propres à chaque patient.
			\item La date d'administration est importante, il faut donc réduire au maximum les retards.
		\end{itemize}
		
		Les traitements étant coûteux, $\approx 400$€, il est nécessaire de pouvoir planifier ces derniers de manière efficace afin d'éviter au maximum le désaccord avec les contraintes citées précédemment.
		
		Le processus de production d'un traitement est le suivant:
		\begin{itemize}
			\item Prescription du traitement pour les patients: type de chimiothérapie, dosage, horaire, etc.
			\item Production de la chimio:
				\begin{itemize}
					\item Passage sur le premier isolateur.
					\item Passage sur le deuxième isolateur.
					\item Passage sur le troisième isolateur.
				\end{itemize}
			\item Livraison
		\end{itemize}
		
		Des éléments important sont à noter:
		\begin{itemize}
			\item Le passage sur les isolateurs doit être fait dans l'ordre.
			\item Le temps de passage sur chaque machine est unique pour chaque patient.
			\item Un seul véhicule est disponible pour la livraison.
		\end{itemize}
		
		L'outil à développer vise à aider à la décision pour la planification des traitements ainsi que leur livraison.
		
	\chapter{Spécifications du logiciel} %TODO
		Afin de généraliser l'implémentation, nous considérons le nombre de machines (isolateurs) comme étant variable pour chaque instance. Par la suite, nous désignerons les traitements par "tâches".
		
		Ce projet s'appuie sur un programme déjà existant, développé dans le langage Python. Celui-ci a été réalisé de manière à amorcer une solution à ce problème, de façon simple. De ce fait, le programme n'a pas été conçu pour l'optimisation : le choix du langage implique une baisse de performances notable. On le remarque surtout lorsque le nombre de machines et de traitement augmente, passé un certain seuil l'algorithme n'est plus capable de produire suffisamment d'itérations pour obtenir un résultat convenable. C'est pourquoi notre tâche est de l'implémenter dans un langage plus efficace : le C.
		\section{Cahier des charges}
			Le cahier des charges de ce projet est relativement simple et vise à proposer des solutions d'ordonnancement pour la production et la livraison des traitements, tout en évitant au maximum les retards. De plus, la planification doit s'effectuer dans un temps raisonnable ($\frac{\text{nombre de machines} \times \text{nombre de tâches}}{4}$). L'objectif principal est de reproduire les fonctionnalités déjà présentes dans le programme existant (algorithme Tabou s'appuyant sur des méthodes de recherche : swap, EBSR et EFSR, expliqués plus en détail dans \autoref{methR}), tout en apportant des améliorations et des fonctionnalités supplémentaires.
			
			Comme entrées, nous disposons de fichiers représentant des situations (nous les appellerons "instances" par la suite), contenant les informations suivantes :
			\begin{itemize}
				\item Nombre de machines
				\item Nombre de tâches
				\item Temps de production par machine et par tâche
				\item Date limite de livraison
				\item Distances entre les points de livraison pour chaque tâche
			\end{itemize}
			
			Comme sortie, on nous demande un fichier texte contenant :
			\begin{itemize}
				\item Le temps de calcul de la solution
				\item Le temps de retard total (appelé "score" par la suite)
				\item L'ordre de production et de livraison
			\end{itemize}
			
			Nous devons également être en mesure de choisir les critères de recherche de la meilleure solution (par exemple, désactiver l'EBSR ou le cache, ou modifier le seuil de diversification).
			
		\section{Codage}
			Dans ce problème, nous pouvons différencier deux types de codage : direct et indirect.
			\begin{itemize}
				\item Le codage direct s'effectue en calculant l'ordre de production et l'ordre de livraison pendant la recherche de la meilleure solution ; le calcul du score se fait donc simplement.
				\item Le codage indirect s'effectue en calculant uniquement le regroupement en batchs de livraison : les ordres de production et de livraison sont calculés en même temps que le score.
			\end{itemize}
			
			Nous devons produire une implémentation du codage indirect.
			
			%TODO Schema des codages
		
		\section{Étude du code Python}
			Python est un langage interprété. Bien qu'ayant de multiples avantages, les performances sont fortement amoindries, et cela a un fort impact sur ce genre d'applications où le volume de calcul est important. Malgré cela, sa syntaxe proche d'un algorithme en pseudo-code le rend plus facile à prendre en main.
			
			Cet apriori ne s'est cependant pas appliqué à notre cas, car différents élément rendent la lecture du code difficile :
			\begin{itemize}
				\item Les variables globales sont utilisées à outrance. De ce fait, in est plus ardu de suivre ces variables et de comprendre de quelle façon elles doivent évoluer.
				\item La convention de nommage consistant à utiliser un minimum de caractères, bien qu'acceptable lorsqu'utilisée avec parcimonie, entraîne une perte de clarté et d'efficacité (on oublie facilement et rapidement le sens d'une variable si l'on ne s'en sert pas assez régulièrement).
			\end{itemize}
			
			Par conséquent, nous avons décidé de découper notre code en structures logiques et de les rendre les plus indépendantes possible. Cela permet de faciliter la lecture par des personnes extérieures au projet, ou simplement de rendre le code plus évolutif et maintenable.
			
			De plus, le code Python comporte plusieurs blocs de code fortement similaires, par exemple les appels aux fonctions de recherche. Nous détaillerons ce cas plus en détail dans \autoref{searchfunc}.
			
			De manière similaire, certaines fonctions sont appelées bien plus souvent que nécessaire, ce qui impacte lourdement les performances. On remarque notamment la fonction evalue() ; nous parlerons d'une solution dans \autoref{cache}.
			
			Enfin, le code comporte quelques erreurs qui influencent la façon dont les étapes de recherche sont effectuées. On ne peut donc pas comparer pas à pas le code Python et le code C ; et nous devons également prêter attention à ces erreurs pour ne pas les implémenter par mégarde. Cela justifie d'autant plus l'utilisation de tests unitaire (décrits dans \autoref{unit}).
			
		
	\chapter{Modélisation du logiciel} %TODO : Clément, petite intro?
		\section{Structure générale — UML}
			Le projet est séparé en deux grosses parties: production et tests.
			Le code de production se trouve dans src/prod et le code de tests dans src/unit.
			
			Chacun d'entre eux contiennent les fichiers .c ainsi qu'un dossier headers contenant les fichiers .h.
			
			\img{UML.png}{Liens entre les différents fichiers/structures}{0.45}

		\section{Rôles des différents éléments}
			Compte tenu de l'ampleur de ce projet, il est important de découper correctement le code en plusieurs éléments ; chacun d'eux a un rôle bien défini. On distinguera 3 catégories dans lesquelles s'inscrivent les structures de données et leurs fonctions : les instances, les solutions et le tabou.
			
			\subsection{Instance}
				Une instance d'un problème à résoudre est représentée par la structure Instance. Cette dernière contient le nombre de tâches et de machines, une liste de tâches ainsi qu'une matrice des distances entre chaque tâche (pour la livraison). Les tâches sont, elles, représentées par la structure Task contenant une liste des temps de production par machine, ainsi qu'une date de livraison. On se réfère ensuite aux différentes tâches en utilisant leur indice dans la liste.
				
			\subsection{Solution}
				Chaque solution admissible à notre problème est représentée par la structure Solution. Celle-ci comporte le nombre de batchs de livraison, une liste contenant ces derniers ainsi que les informations de la solution calculée ; notons qu'une Solution seule ne décrit que l'ordre et le contenu des batchs, et non l'ordre interne de chacun. Ceci est le rôle de la structure SolutionInfo : elle contient l'ordre de chaque batch l'ordre de production des tâches ainsi qu'une liste des temps auxquels chaque tâche est prête à être livrée.
				
			\subsection{Tabou} %TODO : Clément

			\subsection{Autres} %TODO : Clément

		
	\chapter{Implémentation \& tests} %TODO : Clément, petite intro?
		\section{Implémentation} %TODO : Clément, petite intro?
			\subsection{Transfert du Python au C} %TODO : Clément
		%TODO : Contraintes du C (gestion mémoire, tableaux non dynamiques (du moins moins facilement), ...)
		%TODO : Chemminement, ordre de réalisation du code
		%TODO : Problèmes rencontrés et solutions implémentés/fixes
			\label{methR}
			\subsection{\label{cache}Implémentation d'un système de cache des solutions}
				Lors de la traduction du Python au C, nous avons pu remarquer que les appels à la fonction \textbf{eval()} était très fréquent. De plus cette fonction effectue un travail assez lourd ce qui peut facilement prendre une place importante dans le temps de calcul.
				
				Nous avons donc imaginé un système de cache qui garde une solution calculée (\textbf{SolutionInfo}) en mémoire. De cette manière nous évitons des temps de calculs inutiles.
				
				\img{PythonProfilerTop.png}{Profiler exécuté sur le python}{0.3}
				
				Après l'implémentation du cache, et avec un test sur une petite instance, on a pu remarquer que le temps passé sur le calcul du score est le même avec ou sans cache, à savoir environ $43\%$.
				
				Cela est surement du au fait que les packs traités pour cette instance sont de taille $\leq 3$ donc le calcul de l'ordonnancement reste assez simple. Faire les tests sur une instance plus grande serait sûrement plus intéressant. %TODO : Test bigger instance?
			
			\subsection{Diversification aléatoire} %TODO : Clément
			\subsection{Calcul différent de l'itinéraire}
				Le calcul de l'ordre de production joue un rôle important mais l'ordre de livraison aussi. Afin de pouvoir tester différents résultats nous avons décider 2 façons de calculer l'ordre de livraison.
				
				La première méthode est celui transposé depuis le Python, et consiste à livrer dans l'ordre des dates dues. On peut se dire que cette méthode est optimale. Cependant il ne faut pas oublier les temps de voyage entre les points de livraison. Par exemple si on a deux zones A et B qui sont très très loin l'une de l'autre et que les dates dues nous font livrer par alternance A et B, on va passer la plus part du temps sur la route. De manière instinctive on aurait plus tendance à livrer zone par zone.
				
				C'est exactement ce que fait la seconde méthode. Cette fois-ci on livre les produits en allant toujours au plus proche voisin. Cette méthode n'est pas la plus optimale non plus: certes elle diminue les temps de trajet mais elle ne prends plus en compte du tout les dates dues.
				
				Il faut donc essayer les différents algorithmes afin de savoir le quel est le plus adapté au problème courant.
				
				On peut envisager de faire un algorithme qui ferai le mixe des deux: limiter les trajets tout en tenant compte des dates dues. Cependant on peut se poser la question si faire cela est vraiment rentable. En effet nous pourrons éventuellement réduire les temps de retard, mais cela sera au count d'un algorithme plus complexe et qui par conséquent sera moins rapide.
				
				Cette implémentation serait rapide à intégrer au code existant. Pas besoin de fortes modifications, juste écrire le code de la fonction et l'intégrer dans une condition:
				\begin{csource}
else if(taskCount > 3)
{
	if(DELIVERY_NEAREST_NEIGHBOR)
		sequence = sequencer_sequenceDeliveriesNearestNeighbor(instance, taskCount, tasks, initialDate);
	else
		sequence = sequencer_sequenceDeliveriesDueDate(instance, taskCount, tasks, initialDate);
}
				\end{csource} 
				
			\subsection{\label{searchfunc}Simplification de l'implémentation des méthodes de recherche}
				L'algorithme tabou repose sur l'utilisation de différentes méthodes pour générer un nouveau voisinage. Ces dernières ont une utilisation identique, seul leur algorithme propre change. Nous avions tout d'abord implémenté ces dernières comme dans le python, c'est a dire à la suite dans la partie tabou en recopiant le code encadrant la récupération de la solution.
				
				Pour des raisons de lisibilité et d'évolution, nous avons choisi de changer cette manière de procéder et utilisons maintenant des pointeurs de fonction. C'est pointeurs on un typedef associé:
				\begin{csource}
typedef SearchResult * (*searchFunction)(Solution *, TabuList *, Bool);
				\end{csource}
			
				De cette manière il est très simple d'ajouter une nouvelle méthode de recherche à l'algorithme tabou. Il suffit de déclarer cette fonction en respectant les arguments/retour requis, puis de l'ajouter à un tableau des fonctions disponibles:
				\begin{csource}
int searchFunctionAvailable = 3;
searchFunction searchFunctions[searchFunctionAvailable];
searchFunctions[0] =
	#if TABU_SEARCH_SWAP
		tabu_searchSwap
	#else
		NULL
	#endif
;

searchFunctions[1] =
	#if TABU_SEARCH_EBSR
		tabu_searchEBSR
	#else
		NULL
	#endif
;

searchFunctions[2] =
	#if TABU_SEARCH_EFSR
		tabu_searchEFSR
	#else
		NULL
	#endif
;
				\end{csource}
			
				Le résultat de la fonction sera alors automatiquement géré par le reste de l'algorithme tabou.
			
			\subsection{Manuel d'utilisation}
		
		\section{\label{unit}Tests}
			Des tests unitaires ont été effectués sur l'ensemble des éléments de base du projet. En effet tester la partie algorithme Tabou est difficile puisque cela dépend du nombre d'itérations, des paramètres utilisés, etc. Sachant que la partie Tabou utilise principalement des fonctions implémentés ailleurs, nous nous sommes concentrés dessus.
			
			Ces derniers restent assez simplistes et ne couvrent sûrement pas tout les cas mais ils permettent d'identifier des erreurs contraignantes pour la suite de manière rapide.
			
			Nous allons maintenant détailler un peu plus les tests effectués. Par la suite nous appellerons constructeur les fonctions xxx\_create(), et destructeur les fonctions xxx\_destroy().
			\subsection{Task}
				\begin{itemize}
					\item Vérification du constructeur/destructeur.
					\item Get/Set des dates dues.
					\item Get/Set des temps machines.
				\end{itemize}
				
			\subsection{Instance}
				\begin{itemize}
					\item Vérification du constructeur/destructeur.
					\item Obtention des tâches par date due.
				\end{itemize}
				
			\subsection{Parser}
				\begin{itemize}
					\item Test des valeurs des instances parsées depuis plusieurs fichiers.
				\end{itemize}
				
			\subsection{Pack}
				\begin{itemize}
					\item Vérification du constructeur/destructeur.
					\item Add/Remove/Has tâche.
					\item Switch tâche.
					\item Move tâche.
				\end{itemize}
				
			\subsection{SolutionInfo}
				\begin{itemize}
					\item Vérification du constructeur/destructeur.
					\item Test de l'ordonnancement de production.
					\item Test de l'ordonnancement de livraison.
				\end{itemize}
				
			\subsection{Solution}
				\begin{itemize}
					\item Vérification du constructeur/destructeur.
					\item Copie.
					\item Add/Remove/Has tâche.
					\item Switch tâche.
					\item Move tâche.
				\end{itemize}
				
			\subsection{Sequencer}
				\begin{itemize}
					\item Test des dates de fin de production pour des pack avec des tâches dans un ordre donné.
					\item Test de l'ordonnancement de production pour un pack.
					\item Test du retard de livraison pour des pack avec des tâches dans un ordre donné.
					\item Test de l'ordonnancement de livraison pour un pack.
				\end{itemize}
				
			\subsection{Sort}
				\begin{itemize}
					\item Test du SWAP.
					\item Test d'EBSR.
					\item Test d'EFSR.
				\end{itemize}
				
			\subsection{TabuList}
				\begin{itemize}
					\item Vérification du constructeur/destructeur.
					\item Test de l'ajout/suppression items tabou.
					\item Test si un élément est dans la liste tabou.
					\item Test de clear.
				\end{itemize}
				
			\subsection{SearchResult}
				\begin{itemize}
					\item Vérification du constructeur/destructeur.
				\end{itemize}
		
	\chapter{Résultats obtenus}
		\section{Comparaison avec le python} %TODO : Thomas
		\section{Comparaison avec l'implémentation en codage direct} %TODO -
	
	\chapter{Autres}
		Ce chapitre concerne différents mécanismes qui ont pu être mis en place tout au long du projet ainsi que différentes améliorations possibles au programme.
		
		\section{Parallélisme} %TODO : Clément
		
		\section{Fichier de configuration}
			La mise en place d'un fichier de configuration serait une grande avancée. En effet, cela permettrai d'éviter la recompilation du projet après la modification d'un paramètre.
			
			Cependant cela nous empêcherai d'utiliser des commandes pré-processeur ce qui nous forcerai à faire un bon nombre de conditions if qui auraient toujours la même valeur tout au long de l'exécution.
		
		\section{Github — Travis}
			Nous avons tout au long du projet utilisé un gestionnaire de version (VCS): Git. Ce dernier nous a permit de pouvoir travailler de manière collaborative de manière simplifiée. En effet chacun pouvait se focuser sur une partie précise du projet et ainsi paralléliser un peu le développement.
			
			La gestion des branches sur ce dernier était très simple. Nous faisions notre développement sur une branche dev, et lorsque ce qui avait été réalisé marchait, nous le mergions dans la branche master afin d'avoir une sorte de point de sauvegarde.
			
			Enfin, nous avons ajouté en plus du VCS un outil d'intégration continue (CI) afin de vérifier nos tests, lancer Valgrind, et effectuer des comparaisons au Python. De cette manière nous pouvions nous concentrer plus efficacement sur le développement. Les tests ne sont pas oubliés de cette manière et le feedback sur les tests était fait de manière transparente.
			\img{TravisAll.png}{Aperçu général des builds}{0.5}
			\img{TravisCompare.png}{Résultats des comparaisons}{0.575}
			
			Afin de pouvoir lancer ces comparaisons, un utilitaire en JAVA a été créé. Ce dernier prend une liste d'instance en paramètres et effectue les actions suivantes:
			\begin{itemize}
				\item Execution des instances sur le programme en C et en Python.
				\item Récupération des résultats.
				\item Vérification de la cohérence du score avec la solution fournie.
				\item Comparaison des deux scores.
			\end{itemize}
			
\end{document}